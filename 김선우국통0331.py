# -*- coding: utf-8 -*-
"""김선우국통0331.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1woi_4O91E0gutwunhw3BCDjh8dwLmCVU

p.242~ 자료구조-set

딕셔너리
"""

s= set ([1,2,3,4,3,2]) #set() 함수를 사용하여 생성  
print(s)
s.add(1)
print(s)
s.remove(1)
print(s)
s.update([1,2,3,4,5])
print(s)
s.discard(3)
print(s)
s.clear()
print(s)

s1=set([1,2,3,4,5])
s2=set([3,4,5,6,7])


print(s1.union(s2)) #print(s1|s2) 동일하다

print(s1.intersection(s2)) #print(s1&s2)

print(s1.difference(s2)) #print(s1-s2)

newDict={} #공백 딕셔너리
newDict['떡볶이']=3500
newDict['라면']=2500
newDict['순대']=4000


print(newDict)

newDict={} #공백 딕셔너리
newDict['떡볶이']=3500
newDict['라면']=2500
newDict['순대']=4000
newDict['라면']=50000

print(newDict)


# key가 중복되면 마지막에 들어온 value로 업데이트

menu={'떡볶이': 3500, '라면': 50000, '순대': 4000}
print(menu['라면'])

print(menu.keys()) # .keys()를 통하여 key값을 조회
print(menu.values()) #.values() 를 통하여 값을 조회

for k,v in menu.items():
    print(k,':',v)

    #.items()를 통하여 key와 value값을 받아올 수 있음

print(menu.items())

print('떡볶이' in menu.keys())


print(1500 not in menu.values())

"""collections 모듈"""

# deque
from collections import deque

deque_list= deque()

for i in range(5):
    deque_list.append(i)
print(deque_list)



deque_list = [0,1,2,3,4]
print(deque_list.pop(0))

#pop(0) 작동하지 않음

from collections import deque

deque_list= deque()

for i in range(5):
    deque_list.appendleft(i) #왼쪽 부터 추가
print(deque_list)

deque_list.rotate(2)
print(deque_list)
deque_list.rotate(2)
print(deque_list)

#원형으로 생각 {rotate}기능

"""deque는 연결 리스트의 특성을 지원함
한 쪽으로 연결하면서 다음 요소의 주소를 저장. 마지막 요소를 첫 요소로 연결하여 원형으로 구성 가능.
"""

print(deque(reversed(deque_list)))

deque_list.extend([5,6,7])
print(deque_list)
deque_list.extendleft([8,9,10])
print(deque_list)  #왼쪽 부터 차례대로 추가

"""OrderDict: 순서를 가진 딕셔너리 객체"""

for k,v in menu.items():
    print(k,':',v)

from collections import OrderedDict

def sort_by_key(t):
    return t[0]   #정렬을 정의하는 함수 0번째 인덱스를 뜻함

menu={'떡볶이': 3500, '가지': 50000, '순대': 4000, '김':1000}  #key값(0번째 인덱스) 오름차순 정렬


for k,v in OrderedDict(sorted(menu.items(), key=sort_by_key)).items():
    print(k,':',v)

from collections import OrderedDict

def sort_by_key(t):
    return t[1]   #1번째 인덱스를 뜻함 value가 가장 작은 값 부터 오름차순

menu={'떡볶이':3500, '라면': 50000, '순대': 4000, '튀김':1000}


for k,v in OrderedDict(sorted(menu.items(), key=sort_by_key)).items():
    print(k,':',v)



defaultdict 모듈

from collections import defaultdict
d=defaultdict(lambda:0)  #default값을 0으로 설정
print(d['first'])

from collections import defaultdict
s=[('yellow',1),('blue',2),('yellow',3),('blue',4),('red',1)]
d=defaultdict(list)  #list를 default로 생성  
for k,v in s:
    d[k].append(v)
print(d.items())

"""Counter 모듈"""

from collections import Counter
text=list('elephant')
print(text)

c=Counter(text)   #한 값이 몇 개 가 있는지 dic형태로 만들어줌
print(c)

print(c['e']) #e에 대한 value조회

test='PythonIsFun'
test.lower()

print(test)
#전부 소문자로 바꿔줌

test="hi everyone hello"
test.split()
print(test)

from collections import Counter

text = """A press release is the quickest and easiest way to get free publicity. 
If well written, a press release can result in multiple published articles about your 
firm and its products. And that can mean new prospects contacting you asking you to sell to them. ....""".lower().split()
Counter(text)

from collections import Counter
c=Counter(a=4, b=2)
d=Counter(a=2,b=1)
print(c-d)

"""nametuple 모듈 : 튜플의 형태로 데이터 구조체를 저장하는 방법"""

from collections import namedtuple

point= namedtuple('point',['x','y'])

p=point(11,y=22)

print(p)

print(p.x)
print(p.y)

print(p[0]+p[1])

"""함수(function): 어떤 일을 수행하는 코드의 덩어리, 또는 코드의 묶음
함수의 장점
1. 필요할 때 마다 호출 가능
2. 논리적인 단위로 분할 가능
3. 코드의 캡슐화
"""

def f(x):
    return 2* x +7
def g(x):
    return x**2
x=2
t=3
print(f(t)+g(x)+f(g(t))+g(f(x)))